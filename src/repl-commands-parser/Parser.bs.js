// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Utils = require("../utils/Utils.bs.js");
var Functor = require("../interfaces/Functor.bs.js");
var Applicative = require("../interfaces/Applicative.bs.js");

function fmap(f, p) {
  return /* Parser */{
          runParser: (function (s) {
              var match = Curry._1(p.runParser, s);
              if (match !== undefined) {
                return [
                        match[0],
                        Curry._1(f, match[1])
                      ];
              }
              
            })
        };
}

var ParserFunctor = {
  fmap: fmap
};

var TFP = Functor.TestFunctor(ParserFunctor);

function pure(_p) {
  return /* Parser */{
          runParser: (function (param) {
              
            })
        };
}

function apply(pf, p) {
  return /* Parser */{
          runParser: (function (s) {
              var match = Curry._1(pf.runParser, s);
              if (match === undefined) {
                return ;
              }
              var match$1 = Curry._1(p.runParser, match[0]);
              if (match$1 !== undefined) {
                return [
                        match$1[0],
                        Curry._1(match[1], match$1[1])
                      ];
              }
              
            })
        };
}

var ParserApplicative = {
  fmap: fmap,
  pure: pure,
  apply: apply
};

var TAP = Applicative.TestApplicative(ParserApplicative);

var empty = /* Parser */{
  runParser: (function (param) {
      
    })
};

function alternative(p1, p2) {
  return /* Parser */{
          runParser: (function (s) {
              var match = Curry._1(p1.runParser, s);
              if (match !== undefined) {
                return [
                        match[0],
                        match[1]
                      ];
              }
              var match$1 = Curry._1(p2.runParser, s);
              if (match$1 !== undefined) {
                return [
                        match$1[0],
                        match$1[1]
                      ];
              }
              
            })
        };
}

function some(p) {
  var run = function (_s) {
    while(true) {
      var s = _s;
      if (s.length === 0) {
        return ;
      }
      var x = Curry._1(p.runParser, s);
      if (x !== undefined) {
        return x;
      }
      var match = Utils.splitAt(s, 1);
      _s = match[1];
      continue ;
    };
  };
  return /* Parser */{
          runParser: run
        };
}

var ParserAlternative = {
  fmap: fmap,
  pure: pure,
  apply: apply,
  empty: empty,
  alternative: alternative,
  some: some
};

function runParser(p, s) {
  return Curry._1(p.runParser, s);
}

function parseReplCommand(p, s) {
  return Curry._1(p.runParser, s);
}

exports.ParserFunctor = ParserFunctor;
exports.TFP = TFP;
exports.ParserApplicative = ParserApplicative;
exports.TAP = TAP;
exports.ParserAlternative = ParserAlternative;
exports.runParser = runParser;
exports.parseReplCommand = parseReplCommand;
/* TFP Not a pure module */
