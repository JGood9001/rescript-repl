// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Utils = require("../utils/Utils.bs.js");
var Parser = require("./Parser.bs.js");
var $$String = require("rescript/lib/js/string.js");
var Js_string = require("rescript/lib/js/js_string.js");

function matchStr(stringToMatch, inputStr) {
  return Js_string.slice(0, stringToMatch.length, inputStr) === stringToMatch;
}

function charToString(c) {
  return $$String.make(1, c);
}

function $$char(c) {
  return /* Parser */{
          runParser: (function (s) {
              var match = Utils.splitAt(s, 1);
              var x = match[0];
              if (x === $$String.make(1, c)) {
                return [
                        match[1],
                        x
                      ];
              }
              
            })
        };
}

function str(pattern) {
  return /* Parser */{
          runParser: (function (s) {
              var match = Utils.splitAt(s, pattern.length);
              if (matchStr(pattern, s)) {
                return [
                        match[1],
                        match[0]
                      ];
              }
              
            })
        };
}

var space = /* Parser */{
  runParser: (function (s) {
      var match = Utils.splitAt(s, 1);
      var x = match[0];
      if (" " === x) {
        return [
                match[1],
                x
              ];
      }
      
    })
};

var empty = /* Parser */{
  runParser: (function (s) {
      if ("" === s) {
        return [
                s,
                s
              ];
      }
      
    })
};

function contCollectUntil(_collected, _s, pattern) {
  while(true) {
    var s = _s;
    var collected = _collected;
    if (s.length === 0) {
      return ;
    }
    var match = Utils.splitAt(s, 1);
    var remainingStr = match[1];
    var x = match[0];
    if (x === pattern) {
      return [
              x + remainingStr,
              collected
            ];
    }
    _s = remainingStr;
    _collected = collected + x;
    continue ;
  };
}

function collectUntil(s, pattern) {
  var match = Utils.splitAt(s, 1);
  var remainingStr = match[1];
  var x = match[0];
  if (x === pattern) {
    return [
            x,
            remainingStr
          ];
  } else {
    return contCollectUntil(x, remainingStr, pattern);
  }
}

function takeUntil(pattern) {
  return /* Parser */{
          runParser: (function (s) {
              var match = collectUntil(s, pattern);
              if (match !== undefined) {
                return [
                        match[0],
                        match[1]
                      ];
              }
              
            })
        };
}

var rescriptFileP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (filename, ext) {
            return [
                    filename,
                    ext
                  ];
          }), takeUntil(".")), str(".res"));

var loadCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1, param$2) {
                return {
                        TAG: /* LoadModule */1,
                        _0: param$2[0] + param$2[1]
                      };
              }), str(":load")), space), rescriptFileP);

var startMultiLineCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1) {
            return /* StartMultiLineMode */0;
          }), str(":{")), empty);

var endMultiLineCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1) {
            return /* EndMultiLineMode */1;
          }), str("}:")), empty);

var rescriptCodeStartsWithJsLogP = Parser.ParserApplicative.fmap((function (x) {
        return x;
      }), str("Js.log"));

var rescriptCodeEndsWithJsLogP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (x, param) {
            return x;
          }), Parser.ParserAlternative.some(str("->Js.log"))), empty);

var rescriptCodeStartsOrEndsWithJsLogP = Parser.ParserAlternative.alternative(rescriptCodeStartsWithJsLogP, rescriptCodeEndsWithJsLogP);

var rescriptFileP$1 = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (x, param) {
            return x;
          }), Parser.ParserAlternative.some(str(".res"))), empty);

var javascriptFileP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (x, param) {
            return x;
          }), Parser.ParserAlternative.some(str(".bs.js"))), empty);

var rescriptJavascriptFileP = Parser.ParserAlternative.alternative(rescriptFileP$1, javascriptFileP);

exports.matchStr = matchStr;
exports.charToString = charToString;
exports.$$char = $$char;
exports.str = str;
exports.space = space;
exports.empty = empty;
exports.collectUntil = collectUntil;
exports.contCollectUntil = contCollectUntil;
exports.takeUntil = takeUntil;
exports.loadCommandP = loadCommandP;
exports.startMultiLineCommandP = startMultiLineCommandP;
exports.endMultiLineCommandP = endMultiLineCommandP;
exports.rescriptCodeStartsWithJsLogP = rescriptCodeStartsWithJsLogP;
exports.rescriptCodeEndsWithJsLogP = rescriptCodeEndsWithJsLogP;
exports.rescriptCodeStartsOrEndsWithJsLogP = rescriptCodeStartsOrEndsWithJsLogP;
exports.rescriptFileP = rescriptFileP$1;
exports.javascriptFileP = javascriptFileP;
exports.rescriptJavascriptFileP = rescriptJavascriptFileP;
/* rescriptFileP Not a pure module */
