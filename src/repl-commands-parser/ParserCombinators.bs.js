// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Parser = require("./Parser.bs.js");
var $$String = require("rescript/lib/js/string.js");
var Js_string = require("rescript/lib/js/js_string.js");

function splitAt(s, idx) {
  var x = Js_string.slice(0, idx, s);
  var y = Js_string.slice(idx, s.length, s);
  return [
          x,
          y
        ];
}

function matchStr(stringToMatch, inputStr) {
  return Js_string.slice(0, stringToMatch.length, inputStr) === stringToMatch;
}

function charToString(c) {
  return $$String.make(1, c);
}

function $$char(c) {
  return /* Parser */{
          runParser: (function (s) {
              var match = splitAt(s, 1);
              var x = match[0];
              if (x === $$String.make(1, c)) {
                return [
                        match[1],
                        x
                      ];
              }
              
            })
        };
}

function str(pattern) {
  return /* Parser */{
          runParser: (function (s) {
              var match = splitAt(s, pattern.length);
              if (matchStr(pattern, s)) {
                return [
                        match[1],
                        match[0]
                      ];
              }
              
            })
        };
}

var space = /* Parser */{
  runParser: (function (s) {
      var match = splitAt(s, 1);
      var x = match[0];
      if (" " === x) {
        return [
                match[1],
                x
              ];
      }
      
    })
};

var empty = /* Parser */{
  runParser: (function (s) {
      if ("" === s) {
        return [
                s,
                s
              ];
      }
      
    })
};

function contCollectUntil(_collected, _s, pattern) {
  while(true) {
    var s = _s;
    var collected = _collected;
    if (s.length === 0) {
      return ;
    }
    var match = splitAt(s, 1);
    var remainingStr = match[1];
    var x = match[0];
    if (x === pattern) {
      return [
              x + remainingStr,
              collected
            ];
    }
    _s = remainingStr;
    _collected = collected + x;
    continue ;
  };
}

function collectUntil(s, pattern) {
  var match = splitAt(s, 1);
  var remainingStr = match[1];
  var x = match[0];
  if (x === pattern) {
    return [
            x,
            remainingStr
          ];
  } else {
    return contCollectUntil(x, remainingStr, pattern);
  }
}

function takeUntil(pattern) {
  return /* Parser */{
          runParser: (function (s) {
              var match = collectUntil(s, pattern);
              if (match !== undefined) {
                return [
                        match[0],
                        match[1]
                      ];
              }
              
            })
        };
}

var loadCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.apply(Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1, filename, ext) {
                    return {
                            TAG: /* LoadModule */1,
                            _0: filename + ext
                          };
                  }), str(":load")), space), takeUntil(".")), str(".res"));

var startMultiLineCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1) {
            return /* StartMultiLineMode */0;
          }), str(":{")), empty);

var endMultiLineCommandP = Parser.ParserApplicative.apply(Parser.ParserApplicative.fmap((function (param, param$1) {
            return /* EndMultiLineMode */1;
          }), str("}:")), empty);

exports.splitAt = splitAt;
exports.matchStr = matchStr;
exports.charToString = charToString;
exports.$$char = $$char;
exports.str = str;
exports.space = space;
exports.empty = empty;
exports.collectUntil = collectUntil;
exports.contCollectUntil = contCollectUntil;
exports.takeUntil = takeUntil;
exports.loadCommandP = loadCommandP;
exports.startMultiLineCommandP = startMultiLineCommandP;
exports.endMultiLineCommandP = endMultiLineCommandP;
/* loadCommandP Not a pure module */
