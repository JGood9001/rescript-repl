// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("rescript/lib/js/curry.js");
var REPLLogic = require("./repl-logic/REPLLogic.bs.js");
var Noderepl = require("node:repl");

var Repl = {};

var multilineModeState = {
  contents: {
    active: false,
    rescriptCodeInput: undefined
  }
};

function isRecoverableError(error) {
  if (error.name !== "SyntaxError") {
    return false;
  }
  var re = /^(Unexpected end of input|Unexpected token)/g;
  return re.test(error.message);
}

var convertToJSONString = (function(rescriptStdoutStr) {
        const re = /[a-z]*:/g
        let y = rescriptStdoutStr.split(" ").map(s => re.test(s) ? ["\"", s.split(":")[0], "\"", ":"].join("") : s)
        let z = y.map(s => s.split("\n"))
        let transformed = Array.prototype.concat(...z).join("")
        return JSON.parse(transformed.replaceAll("'", "\"").replaceAll("undefined", "\"None\""))
    });

var handleDirtyWork = (function(callback, value) {
    if (value !== "") {
        try {
            callback(null, JSON.parse(value))
        } catch {
            // Okay... so objects are ending up here as such:
            // '{\n' +
            //     "  first: 'John',\n" +
            //     "  last: 'Jingleheimer',\n" +
            //     "  address: { street: 'STREET', zip: 85923 }\n" +
            //     '}'
            // But you want to have it in the format of a json string, so that
            // the results displayed at the REPL are just as Node repl would display it.
            // Need to wrap all series of characters which precede ":" in single quotes
            // to accomplish this.

            // Create a Regex which gets any series of characters A-Z/a-z not
            // surrounded by single quotes.


            try {
                // This this fails to parse stdout result of None
                callback(null, convertToJSONString(value))
            }  catch {
                console.log(value)
                callback(null, "couldnt parse None")
            }
        }
    } else {
        callback(null, value)
    }
  });

async function $$eval(codeStr, context, filename, callback) {
  if (multilineModeState.contents.active) {
    var prevCodeStr = multilineModeState.contents.rescriptCodeInput;
    if (prevCodeStr !== undefined) {
      multilineModeState.contents = {
        active: true,
        rescriptCodeInput: prevCodeStr + "\n" + codeStr
      };
      return Curry._2(callback, undefined, "");
    } else {
      console.log("INVARIANT VIOLATION: The RescriptCode case expects for there to be some rescriptCodeInput present.");
      return ;
    }
  }
  var rescriptStdout = await REPLLogic.handleBuildAndEval(codeStr, {
        read: REPLLogic.FileOperations.read,
        write: REPLLogic.FileOperations.write
      }, REPLLogic.RescriptBuild, REPLLogic.EvalJavaScriptCode);
  if (rescriptStdout !== undefined) {
    return handleDirtyWork(callback, rescriptStdout);
  } else {
    return handleDirtyWork(callback, "");
  }
}

async function endMultiLineMode(replServer) {
  var codeStr = multilineModeState.contents.rescriptCodeInput;
  var rescriptStdout = await REPLLogic.handleBuildAndEval(codeStr, {
        read: REPLLogic.FileOperations.read,
        write: REPLLogic.FileOperations.write
      }, REPLLogic.RescriptBuild, REPLLogic.EvalJavaScriptCode);
  multilineModeState.contents = {
    active: false,
    rescriptCodeInput: undefined
  };
  if (rescriptStdout !== undefined) {
    console.log(rescriptStdout);
  } else {
    console.log("");
  }
  replServer.displayPrompt();
}

function startMultiLineMode(replServer, param) {
  multilineModeState.contents = {
    active: true,
    rescriptCodeInput: ""
  };
  replServer.displayPrompt();
}

function loadModule(replServer, moduleName) {
  REPLLogic.handleLoadModuleCase(moduleName, {
        read: REPLLogic.FileOperations.read,
        write: REPLLogic.FileOperations.write
      }, REPLLogic.RescriptBuild, REPLLogic.EvalJavaScriptCode);
  replServer.displayPrompt();
}

function reset(replServer, FO, param) {
  Curry._2(FO.write, /* Filepath */{
        _0: "./src/RescriptREPL.res"
      }, "");
  replServer.displayPrompt();
}

function run_repl(param) {
  console.log("Welcome to ReScript REPL\n");
  console.log("Available Commands:");
  console.log(".load   - Load a Module into the current REPL context");
  console.log(".reset  - To clear ReScript code saved in the current REPL context");
  console.log(".{:     - Start Mutliline Mode");
  console.log(".}:     - End Mutliline Mode");
  var replServer = Noderepl.start({
        prompt: "> ",
        eval: $$eval
      });
  replServer.defineCommand(":{", (function (param) {
          return startMultiLineMode(replServer, param);
        }));
  replServer.defineCommand("}:", (function (param) {
          endMultiLineMode(replServer);
        }));
  replServer.defineCommand("load", (function (param) {
          return loadModule(replServer, param);
        }));
  var partial_arg_read = REPLLogic.FileOperations.read;
  var partial_arg_write = REPLLogic.FileOperations.write;
  var partial_arg = {
    read: partial_arg_read,
    write: partial_arg_write
  };
  replServer.defineCommand("reset", (function (param) {
          return reset(replServer, partial_arg, param);
        }));
  replServer.on("exit", (function (param) {
          console.log("exiting");
          try {
            Fs.unlinkSync("./src/RescriptRepl.res");
            Fs.unlinkSync("./src/RescriptRepl.bs.js");
            Fs.unlinkSync("./src/evalJsCode.js");
            return ;
          }
          catch (exn){
            return ;
          }
        }));
}

exports.Repl = Repl;
exports.multilineModeState = multilineModeState;
exports.isRecoverableError = isRecoverableError;
exports.convertToJSONString = convertToJSONString;
exports.handleDirtyWork = handleDirtyWork;
exports.$$eval = $$eval;
exports.endMultiLineMode = endMultiLineMode;
exports.startMultiLineMode = startMultiLineMode;
exports.loadModule = loadModule;
exports.reset = reset;
exports.run_repl = run_repl;
/* fs Not a pure module */
