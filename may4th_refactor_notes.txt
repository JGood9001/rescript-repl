// May 4th FIX:
// - If ./src/RescriptRepl.res | ./src/RescriptRepl.bs.js don't exist when "close" event is received,
//   then don't attempt to remove them... prints out a node error to the user if you do.

// Need to see if I can create an interface which wraps Readline (so I can supply a test instance)
// https://github.com/TheSpyder/rescript-nodejs/blob/main/src/Readline.res
// https://nodejs.org/api/readline.html#class-interfaceconstructor
// https://github.com/TheSpyder/rescript-nodejs/blob/main/src/Readline.res#L57
// Every instance is associated with a single input Readable stream and a single output Writable stream.
// The output stream is used to print prompts for user input that arrives on, and is read from, the input stream.
// ^^ So the test implementation will need to emulate this.

// Will I need to create this in order to ensure that the files which the rescript code entered at the repl
// is being cleaned up properly?
// https://nodejs.org/api/readline.html#event-close

What do I do about Process.stdin and stdout?
How can I create an interface which satisfies both the real instances and the ones required for test.
let rl = Readline.make(
    Readline.interfaceOptions(~input=Process.process->Process.stdin, ~output=Process.process->Process.stdout, ()),
)

type ReadlineInterface = {
    make,
    close,
}

-- All right, I need to double check my OCaml tagless final notes
--
TAGLESS FINAL NOTES (can include link to rescript playground with example code in the blog post)
https://rescript-lang.org/try?version=v10.1.2&code=PTAEEEBtNAzAnA9gW1AFwBYFNQGcsDGaAlogHYD6siArvAHTIyzGQ7FnoCGA5m7riocukAFAhQAdy644iaIkkceoEeRVLM6DMVkAjSIhUAHRLjQAucWAxo0x3BZDysAa1xcyAE3jJPALwBPGld6SUR4L2N4LAF6AhRgACYABgBGABZgFIA2YDSADmAEFABaRD0AK0I0UpEeLD14GVK0RFKWMhFIQNbeflxSjjQseGisEfhBpOBRZEQvGjZ0QOMcAFEAD2MoFQBeUABvUVAASDRVnDRQUVO2a8hia4tQYdA9gD50E7P71S8vKAXtdPuh3l80KIAL6iUQXNagLAANxE71A6xRkAAFMMAJSwiQYGSuLDQKS0SBeADkSJwXBobQaZFGXBGgMwOAadlGcng2l0KzWVNkkmaxjWgMxNCwoj+yNRByxGJEWLIuNx4NAZFh80Wy2VkC2xjRx1AgquaPlYjNf0eIK1moNqvxNom-0Bis2ABpQIENaCnVasZsNQBqRGYrF+-Ew6ygAAq2ER2xiAlInCxaVA4axSWzoAAzOrXrIYuN8GQ2apZNQFJJZFjYFwCKwnqysIC9IE4MQptcCJAZLJdUtYrirHKs4qR8slUD0dtdlInhhzWCDlbi59but6FwAUr6HbM7ifbvj0l1TqFqO1wBZJZLg6m04cAc0LwbReQHg-H53N1kCWecQQhTVIVjGccAfQ1MSNE0TlfMh30-dE4O2P8zQA64gJgT0fT9R1IyDENQAAKgjFVo2hWE5Tzacb1nO95xgpdNFXeELQ3TEtw+W470YJYsQE480lPUARKeXMrzjSQsF7LwfXCMgqX7FBjFYHB2Noa4OVAKDQD0eSyA0MUJVeThjC4GJK2wfBcB9PQGW0Vk410FTdKTAgZHYTgAHkAGEuCYWU3SRKdESSLEDOEpYDSNK8gA
--
// All from the section_four.ml file in tagless_final
// was following along with this blog post:
// https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/
module type ExpAlg = {
 	type t 
	let lit : int => t
  	let add : t => t => t
}

type eval = Eval(int)

// haskell would've autogenerated the getter for this type's wrapped value
let eval = (Eval(n)) => n

module EvalExp = {
  type t = eval
  let lit = n => Eval(n)
  let add = (x, y) => Eval(eval(x) + eval(y))
}

// The expression (1 + (2 + 3)) is represented as follows (facilitated by first class modules):
let e1 = (module (E : ExpAlg with type t = eval)) =>
	E.add(E.lit(1), E.lit(2))

module type MulAlg = {
 	include ExpAlg
  
  	let mul : t => t => t
}

module MulEvalExp = {
 	include EvalExp
  
  	let mul = (x, y) => Eval(eval(x) * eval(y))
}

let e2 = (module (M : MulAlg with type t = eval)) =>
	M.mul(M.lit(1), M.lit(2))

// weird, won't compile without the module being wrapped in parentheses, but that
// isn't the case in OCaml
let v1 = e2(module (MulEvalExp))
--
END TAGLESS FINAL NOTES
--