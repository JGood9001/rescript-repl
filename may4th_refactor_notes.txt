// May 4th FIX:
// - If ./src/RescriptRepl.res | ./src/RescriptRepl.bs.js don't exist when "close" event is received,
//   then don't attempt to remove them... prints out a node error to the user if you do.

// Need to see if I can create an interface which wraps Readline (so I can supply a test instance)
// https://github.com/TheSpyder/rescript-nodejs/blob/main/src/Readline.res
// https://nodejs.org/api/readline.html#class-interfaceconstructor
// https://github.com/TheSpyder/rescript-nodejs/blob/main/src/Readline.res#L57
// Every instance is associated with a single input Readable stream and a single output Writable stream.
// The output stream is used to print prompts for user input that arrives on, and is read from, the input stream.
// ^^ So the test implementation will need to emulate this.

// Will I need to create this in order to ensure that the files which the rescript code entered at the repl
// is being cleaned up properly?
// https://nodejs.org/api/readline.html#event-close

What do I do about Process.stdin and stdout?
How can I create an interface which satisfies both the real instances and the ones required for test.
let rl = Readline.make(
    Readline.interfaceOptions(~input=Process.process->Process.stdin, ~output=Process.process->Process.stdout, ()),
)

type ReadlineInterface = {
    make,
    close,
}

-- All right, I need to double check my OCaml tagless final notes
--
TAGLESS FINAL NOTES (can include link to rescript playground with example code in the blog post)
https://rescript-lang.org/try?version=v10.1.2&code=PTAEEEBtNAzAnA9gW1AFwBYFNQGcsDGaAlogHYD6siArvAHTIyzGQ7FnoCGA5m7riocukAFAhQAdy644iaIkkceoEeRVLM6DMVkAjSIhUAHRLjQAucWAxo0x3BZDysAa1xcyAE3jJPALwBPGld6SUR4L2N4LAF6AhRgACYABgBGABZgFIA2YDSADmAEFABaRD0AK0I0UpEeLD14GVK0RFKWMhFIQNbeflxSjjQseGisEfhBpOBRZEQvGjZ0QOMcAFEAD2MoFQBeUABvUVAASDRVnDRQUVO2a8hia4tQYdA9gD50E7P71S8vKAXtdPuh3l80KIAL6iUQXNagLAANxE71A6xRkAAFMMAJSwiQYGSuLDQKS0SBeADkSJwXBobQaZFGXBGgMwOAadlGcng2l0KzWVNkkmaxjWgMxNCwoj+yNRByxGJEWLIuNx4NAZFh80Wy2VkC2xjRx1AgquaPlYjNf0eIK1moNqvxNom-0Bis2ABpQIENaCnVasZsNQBqRGYrF+-Ew6ygAAq2ER2xiAlInCxaVA4axSWzoAAzOrXrIYuN8GQ2apZNQFJJZFjYFwCKwnqysIC9IE4MQptcCJAZLJdUtYrirHKs4qR8slUD0dtdlInhhzWCDlbi59but6FwAUr6HbM7ifbvj0l1TqFqO1wBZJZLg6m04cAc0LwbReQHg-H53N1kCWecQQhTVIVjGccAfQ1MSNE0TlfMh30-dE4O2P8zQA64gJgT0fT9R1IyDENQAAKgjFVo2hWE5Tzacb1nO95xgpdNFXeELQ3TEtw+W470YJYsQE480lPUARKeXMrzjSQsF7LwfXCMgqX7FBjFYHB2Noa4OVAKDQD0eSyA0MUJVeThjC4GJK2wfBcB9PQGW0Vk410FTdKTAgZHYTgAHkAGEuCYWU3SRKdESSLEDOEpYDSNK8gA
--
// All from the section_four.ml file in tagless_final
// was following along with this blog post:
// https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/
module type ExpAlg = {
 	type t 
	let lit : int => t
  	let add : t => t => t
}

type eval = Eval(int)

// haskell would've autogenerated the getter for this type's wrapped value
let eval = (Eval(n)) => n

module EvalExp = {
  type t = eval
  let lit = n => Eval(n)
  let add = (x, y) => Eval(eval(x) + eval(y))
}

// The expression (1 + (2 + 3)) is represented as follows (facilitated by first class modules):
let e1 = (module (E : ExpAlg with type t = eval)) =>
	E.add(E.lit(1), E.lit(2))

module type MulAlg = {
 	include ExpAlg
  
  	let mul : t => t => t
}

module MulEvalExp = {
 	include EvalExp
  
  	let mul = (x, y) => Eval(eval(x) * eval(y))
}

let e2 = (module (M : MulAlg with type t = eval)) =>
	M.mul(M.lit(1), M.lit(2))

// weird, won't compile without the module being wrapped in parentheses, but that
// isn't the case in OCaml
let v1 = e2(module (MulEvalExp))
--
END TAGLESS FINAL NOTES
--


-- So on the first day I wrote this out, working out how I'd structure things:

// The general flow (not specific to my particular use case):
// 1. Create a ReadLine instance which facilitates receiving from stdin and sending output back to the user via stdout (Readline.make and Readline.interfaceOptions)
// 2. 
// Finally, Clean up upon "close" event being initiated via Ctrl+D | Ctrl+C sent by the user

// The interface to the repl (specific to this domain) logic:
// 

// ^^ I imagine both of these being passed to the repl function (as first class modules implementing an algebra)

// 1. CommandLineIO
// 2. Logic

// let e1 = (module (E : ExpAlg with type t = eval)) =>
	// E.add(E.lit(1), E.lit(2))

// So the user can provide Readline.Interface.t, as you want to keep the underlying implementation hidden from the logic that handles the sequencing
// of the commandlineioalg and domainlogicalg function invocations.
type commandLineIO<'a> = 'a

// well Readline.make returns a Interface.t
module type CommandLineIOAlg = {
    type t

    let make : () => t
    let prompt : t => string => (string => ()) => unit
    let close : t => unit
}

module type DomainLogicAlg = {
    // parser will come in handy here...
    let handleUserInput : string => ()
    // any way to make this optional?
    let cleanup : () => unit
}

// will be used when creating the prod instance for CommandLineIOAlg
let prompt_2 = (rl, query, cb) =>
    Promise.make((resolve, _reject) => rl->Readline.Interface.question(query, x => resolve(. x)))
    ->Promise.then(user_input => cb(user_input))
    ->ignore


let rec repl_2 = (module (CLIO : CommandLineIOAlg), module (DL : DomainLogicAlg)) => {
    // 1. Create instance of commandline
    let cliInterface = CLIO.make()
    // 2. Setup cleanup function upon cliInterface receiving the "close" event
    // Will require invoking the passed in function whenever... (need to implement the getting input from the user first)
    // invoke domainlogicalg's cleanup implementation + set mutable variable to indicate that repl's while loop should be broken out of.
    // rl
    // ->Readline.Interface.on(Event.fromString("close"), () => {
    // Js.log("See You Space Cowboy")
    // // remove files
    // unlinkSync("./src/RescriptRepl.res")
    // unlinkSync("./src/RescriptRepl.bs.js")
    // }) -> ignore
    // For the test instance, this would require that the type t is mutable so that event handlers may be stored...
    // cliInterface.on("close", () => {
    //   DL.cleanup()
    //   Js.log("See you Space Cowboy")    
    // })

    // Getting input from the user...
    // prompt("\u03BB> ") -> Promise.then(user_input => {
    // Can I hide the fact that promises are being used here?
    // where prompt currently is:
    // let prompt = query => Promise.make((resolve, _reject) => rl->Readline.Interface.question(query, x => resolve(. x)))
    // I suppose just moving the Promise.then into the prompt function and having repl provide a callback function to prompt will work.
    // while loop here
    CLIO.prompt(cliInterface, "\u03BB> ", DL.handleUserInput)
    // handleUserInput actually also needs access to cliInterface's close function,
    // as that's what I was doing below in the first implementation :exit => rl->Readline.Interface.close
    // All right... now due to DomainLogicAlg (the implementation specific to rescript repl) needing to handle file operations
    // I really don't know how to go about implementing it such that there would be instances for both prod/test.
    // Well after thinking about it a little more, the handle_get_next_contents and (prev_contents/nexdt_contents stuff is domain specific)
    // and shouldn't be a concern to the repl function.
    // Maintaining that within the DomainLogicAlg would imply some kind of mutable state if I'm not going to pass it explicitly
    // through the recursive invocations (ahhh, but I don't even need to recurse, this can just be a loop now).
    // Ultimately, the implementation of DomainLogicAlg will need to include FilesAlg for which a prod/test instance of that
    // may be provided.

}

// Rescript REPL Domain specific logic (to be used within handleUserInput)...
// 1. save
// 2. write
// 3. rollback
// 4. unlinkSync (which is NodeJS' delete file essentially...)
// 5. rewrite (implemented in terms of delete and write) replacing contents of a current file with a provided string

// ^^ Refactoring ideation...

-- Then at this point, I wanted to split things out into separate files (but I still want to maintain the linear progression of how
-- the final solution was arrived at... so I'll keep noting ideas here)

-- Day 2

Worked on writing the prod implementations of CommandLineIOAlg and DomainLogicAlg.

After that I considered how the test instance of CommandLineIOALg might look, and a quick glance at
the production implementation made me realize I can just use a CommandLineIOAlg.t with a ref
to store callbacks.

Here's what I wrote in my prototype:
rl
->Readline.Interface.on(Event.fromString("close"), () => {
  Js.log("See You Space Cowboy")
  // remove files
  unlinkSync("./src/RescriptRepl.res")
  unlinkSync("./src/RescriptRepl.bs.js")
}) -> ignore

And the function close on CommandLineIOAlg for the prod implementation is just:
let close = rl => rl->Readline.Interface.close

So I can add an on function to CommandLineIOAlg
let on : t => string => (() => ()) => ()

Prod impl:
let on = (rl, event, cb) =>
    rl->Readline.Interface.on(Event.fromString(event), cb)

Test impl:
type test_cli = {
    // https://rescript-lang.org/docs/manual/latest/api/js/dict
 	event_handlers: Js.Dict.t<() => ()>
}

let add_handler = (x: test_cli, event, cb) => {
  Js.Dict.set(x.event_handlers, event, cb)
}

where CommandLineIOAlg.t = test_cli

The test implementation ends up looking very similar to the prod implementation.
Indeed, rl more than likely is leveraging mutation and operates in a similar manner as the
test_cli.
let on = (x, event, cb) =>
    x->add_handler(event, cb)

And close
let handle_close = (x: test_cli) => {
    switch Js.Dict.get(x.event_handlers, "close") {
        | Some(f) => f()
        | None => ()
    }
}

let close = x => x->handle_close

